// SendAnywhere Clone - Frontend JavaScript
class SendAnywhereApp {
    constructor() {
        this.socket = null;
        this.peer = null;
        this.selectedFiles = [];
        this.currentCode = null;
        this.isReceiver = false;
        this.receivedFiles = [];
        
        // Preview system properties
        this.currentFileIndex = 0;
        this.currentPageIndex = 0;
        this.totalPages = 1;
        this.previewData = null;
        
        this.init();
    }
    
    init() {
        this.connectSocket();
        this.setupEventListeners();
        this.setupFileHandling();
        this.checkPDFJSAvailability();
    }
    
    checkPDFJSAvailability() {
        // Check if PDF.js is available
        if (typeof pdfjsLib !== 'undefined') {
            console.log('✓ PDF.js loaded successfully, version:', pdfjsLib.version);
        } else {
            console.error('✗ PDF.js not available');
            // Show a warning toast
            setTimeout(() => {
                this.showToast('PDF preview may not work properly - PDF.js library not loaded', 'warning');
            }, 2000);
        }
    }
    
    connectSocket() {
        // Dynamically determine the server URL based on current location
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const hostname = window.location.hostname;
        let port = window.location.port;
          // If we're on port 8000 (frontend), connect to backend on 4999
        // If we're on port 4999 (backend serving frontend), connect to same port
        let serverUrl;
        if (port === '8000') {
            serverUrl = `http://${hostname}:4999`;
        } else if (port === '4999' || !port) {
            serverUrl = `http://${hostname}:4999`;
        } else {
            // Default fallback
            serverUrl = 'http://localhost:4999';
        }
        
        console.log(`Connecting to socket server at: ${serverUrl}`);
        
        this.socket = io(serverUrl, {
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionAttempts: 5,
            timeout: 20000,
            forceNew: true
        });        
        this.socket.on('connect', () => {
            console.log('Connected to server with socket ID:', this.socket.id);
            this.showToast(`Connected to server (ID: ${this.socket.id.substring(0, 8)}...)`, 'success');
        });
        
        this.socket.on('disconnect', (reason) => {
            console.log('Disconnected from server:', reason);
            if (reason !== 'io client disconnect') {
                this.showToast('Connection lost. Attempting to reconnect...', 'warning');
            }
        });

        this.socket.on('reconnect', () => {
            console.log('Reconnected to server');
            this.showToast('Reconnected to server', 'success');
        });

        this.socket.on('reconnect_failed', () => {
            console.log('Failed to reconnect to server');
            this.showToast('Connection failed. Please try again.', 'error');
        });

        this.socket.on('error', (error) => {
            console.error('Socket error:', error);
            this.showToast('Connection error: ' + (error.message || error), 'error');
        });

        this.socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            this.showToast('Failed to connect to server', 'error');
        });

        this.socket.on('code-generated', (data) => {
            this.handleCodeGenerated(data);
        });

        this.socket.on('receiver-joined', (data) => {
            this.handleReceiverJoined(data);
        });

        this.socket.on('joined-room', (data) => {
            this.handleJoinedRoom(data);
        });

        this.socket.on('signal', (data) => {
            this.handleSignal(data);
        });
        
        this.socket.on('code-expired', (data) => {
            this.showToast('Transfer code expired', 'warning');
            this.resetTransfer();
        });

        this.socket.on('error', (data) => {
            console.error('Server error:', data);
            this.showToast(data.message || 'An error occurred', 'error');
        });
    }

    setupEventListeners() {        // File selection
        document.getElementById('file-input').addEventListener('change', (e) => {
            console.log('File input changed, files:', e.target.files.length);
            this.handleFileSelection(e.target.files);
        });

        // Generate code button
        document.getElementById('generate-code-btn').addEventListener('click', () => {
            this.generateCode();
        });

        // Copy code button
        document.getElementById('copy-code-btn').addEventListener('click', () => {
            this.copyCode();
        });

        // Receive button
        document.getElementById('receive-btn').addEventListener('click', () => {
            this.joinTransfer();
        });

        // Receive code input
        const codeInput = document.getElementById('receive-code-input');
        codeInput.addEventListener('input', (e) => {
            // Filter to digits only and limit length
            e.target.value = e.target.value.replace(/\D/g, '').slice(0, 6);
            
            // Visual cue when 6 digits are entered
            if (e.target.value.length === 6) {
                e.target.style.borderColor = '#4CAF50';
                document.getElementById('receive-btn').classList.add('bounce-in');
            } else {
                e.target.style.borderColor = '';
                document.getElementById('receive-btn').classList.remove('bounce-in');
            }
        });
        
        // Input focus effects
        codeInput.addEventListener('focus', () => {
            codeInput.parentElement.classList.add('focused');
        });
        
        codeInput.addEventListener('blur', () => {
            codeInput.parentElement.classList.remove('focused');
        });
        
        // QR Scanner in Receive Section
        document.getElementById('scan-qr-btn').addEventListener('click', () => {
            this.startQRScanner();
        });

        document.getElementById('stop-camera-btn').addEventListener('click', () => {
            this.stopQRScanner();
        });

        // Cancel/Reset buttons
        document.getElementById('cancel-transfer-btn').addEventListener('click', () => {
            this.cancelTransfer();
        });

        document.getElementById('reset-transfer-btn').addEventListener('click', () => {
            this.resetTransfer();
        });

        document.getElementById('cancel-receive-btn').addEventListener('click', () => {
            this.cancelReceive();
        });        // Download all button
        document.getElementById('download-all-btn').addEventListener('click', () => {
            this.downloadAllFiles();
        });        // Make a New Transfer button
        document.getElementById('new-transfer-btn').addEventListener('click', () => {
            this.resetTransfer();
        });
        
        // Preview navigation event listeners
        this.setupPreviewEventListeners();
    }
    
    setupPreviewEventListeners() {
        // File navigation buttons
        const prevFileBtn = document.getElementById('prev-file-btn');
        const nextFileBtn = document.getElementById('next-file-btn');
        
        if (prevFileBtn) {
            prevFileBtn.addEventListener('click', () => {
                this.navigateToFile(this.currentFileIndex - 1);
            });
        }
        
        if (nextFileBtn) {
            nextFileBtn.addEventListener('click', () => {
                this.navigateToFile(this.currentFileIndex + 1);
            });
        }
        
        // Page/slide navigation buttons
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => {
                this.navigateToPage(this.currentPageIndex - 1);
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => {
                this.navigateToPage(this.currentPageIndex + 1);
            });
        }
        
        // Fullscreen button
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', () => {
                this.toggleFullscreen();
            });
        }
          // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Only handle if preview is visible and not typing in input fields
            if (!this.isPreviewVisible() || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            switch (e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift + Left: Previous file
                        this.navigateToFile(this.currentFileIndex - 1);
                    } else {
                        // Left: Previous page
                        this.navigateToPage(this.currentPageIndex - 1);
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift + Right: Next file
                        this.navigateToFile(this.currentFileIndex + 1);
                    } else {
                        // Right: Next page
                        this.navigateToPage(this.currentPageIndex + 1);
                    }
                    break;
                case 'Home':
                    e.preventDefault();
                    if (e.ctrlKey) {
                        // Ctrl + Home: First file
                        this.navigateToFile(0);
                    } else {
                        // Home: First page
                        this.navigateToPage(0);
                    }
                    break;
                case 'End':
                    e.preventDefault();
                    if (e.ctrlKey) {
                        // Ctrl + End: Last file
                        this.navigateToFile(this.selectedFiles.length - 1);
                    } else {
                        // End: Last page
                        this.navigateToPage(this.totalPages - 1);
                    }
                    break;
                case 'F11':
                case 'f':
                    if (e.key === 'f') e.preventDefault();
                    this.toggleFullscreen();
                    break;
                case 'Escape':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                    break;
            }
        });
        
        // Initialize enhanced navigation feedback
        this.addPageNavigationFeedback();
                        this.navigateToFile(this.currentFileIndex - 1);
                    } else {
                        // Left: Previous page
                        this.navigateToPage(this.currentPageIndex - 1);
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.shiftKey) {
                        // Shift + Right: Next file
                        this.navigateToFile(this.currentFileIndex + 1);
                    } else {
                        // Right: Next page
                        this.navigateToPage(this.currentPageIndex + 1);
                    }
                    break;
                case 'Home':
                    e.preventDefault();
                    if (e.ctrlKey) {
                        // Ctrl + Home: First file
                        this.navigateToFile(0);
                    } else {
                        // Home: First page
                        this.navigateToPage(0);
                    }
                    break;
                case 'End':
                    e.preventDefault();
                    if (e.ctrlKey) {
                        // Ctrl + End: Last file
                        this.navigateToFile(this.selectedFiles.length - 1);
                    } else {
                        // End: Last page
                        this.navigateToPage(this.totalPages - 1);
                    }
                    break;
                case 'F11':
                case 'f':
                    if (e.key === 'f') e.preventDefault();
                    this.toggleFullscreen();
                    break;
                case 'Escape':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                    break;
            }
        });
    }
    
    isPreviewVisible() {
        const selectedFilesSection = document.getElementById('selected-files-section');
        return selectedFilesSection && !selectedFilesSection.classList.contains('hidden');
    }
    
    setupFileHandling() {
        const dropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('file-input');

        console.log('Setting up file handling:', { dropZone, fileInput });

        if (!dropZone || !fileInput) {
            console.error('Missing DOM elements:', { dropZone, fileInput });
            return;
        }        // Click to select files
        dropZone.addEventListener('click', () => {
            console.log('Drop zone clicked, opening file input');
            fileInput.click();
        });

        // File input change event
        fileInput.addEventListener('change', (e) => {
            console.log('File input changed, files selected:', e.target.files.length);
            if (e.target.files.length > 0) {
                this.handleFileSelection(e.target.files);
            }
        });// Drag and drop functionality
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            console.log('Drag over detected');
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            console.log('Drag leave detected');
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            console.log('Files dropped:', e.dataTransfer.files.length);
            dropZone.classList.remove('drag-over');
            this.handleFileSelection(e.dataTransfer.files);
        });
    }    handleFileSelection(files) {
        if (files.length === 0) return;
        
        console.log('Handling file selection:', files.length, 'files');
          try {
            this.selectedFiles = Array.from(files);
            console.log('Files processed:', this.selectedFiles.map(f => f.name));
            
            // Show selected files directly under the drop zone within the upload area
            this.showSelectedFilesInDropZone();
            
            // Update the button text to "Upload Files"
            const uploadBtn = document.getElementById('generate-code-btn');
            if (uploadBtn) {
                uploadBtn.textContent = 'Upload Files';
                uploadBtn.classList.add('bounce-in');
                setTimeout(() => uploadBtn.classList.remove('bounce-in'), 500);
            }
            
            // Make sure verification section stays hidden until upload
            const selectedFilesSection = document.getElementById('selected-files-section');
            if (selectedFilesSection) {
                selectedFilesSection.classList.add('hidden');
            }
            
            // Show visual confirmation
            this.showToast(`${files.length} file(s) selected successfully`, 'success');
        } catch (error) {
            console.error('Error in file selection:', error);
            this.showToast('Error processing files: ' + error.message, 'error');
        }
    }displaySelectedFiles() {
        const fileList = document.getElementById('file-list');
        if (!fileList) return;
        
        fileList.innerHTML = '';

        this.selectedFiles.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.innerHTML = `
                <div class="file-info">
                    <i class="fas fa-file"></i>
                    <span class="file-name">${file.name}</span>
                    <span class="file-size">(${this.formatFileSize(file.size)})</span>
                </div>
                <button class="remove-file" onclick="app.removeFile(${index})">
                    <i class="fas fa-times"></i>
                </button>
            `;
            fileList.appendChild(fileItem);
        });
    }    displaySimpleFileList() {
        const fileList = document.getElementById('file-list');
        if (!fileList) return;
        
        // Clear existing content
        fileList.innerHTML = '';
        
        // Add simple file list items (like in 2nd screenshot)
        this.selectedFiles.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'simple-file-item';
            fileItem.innerHTML = `
                <div class="simple-file-info">
                    <i class="fas fa-file-alt"></i>
                    <span class="simple-file-name">${file.name}</span>
                    <span class="simple-file-size">${this.formatFileSize(file.size)}</span>
                </div>
                <button class="simple-remove-file" onclick="app.removeFile(${index})" title="Remove file">
                    <i class="fas fa-times"></i>
                </button>
            `;
            fileList.appendChild(fileItem);
        });
        
        // Add the upload button at the bottom
        const uploadButtonContainer = document.createElement('div');
        uploadButtonContainer.className = 'upload-button-container';
        uploadButtonContainer.innerHTML = `
            <button id="upload-files-btn" class="upload-files-btn">
                <i class="fas fa-cloud-upload-alt"></i>
                Upload Files
            </button>
        `;
        fileList.appendChild(uploadButtonContainer);
        
        // Add event listener to the upload button
        const uploadBtn = document.getElementById('upload-files-btn');
        if (uploadBtn) {
            uploadBtn.addEventListener('click', () => {
                this.generateCode();
            });
        }
    }

    showSelectedFilesInDropZone() {
        const uploadArea = document.getElementById('upload-area');
        if (!uploadArea) return;

        // Check if file list already exists, if not create it
        let fileListContainer = document.getElementById('selected-files-in-dropzone');
        if (!fileListContainer) {
            fileListContainer = document.createElement('div');
            fileListContainer.id = 'selected-files-in-dropzone';
            fileListContainer.className = 'selected-files-in-dropzone';
            
            // Insert after the file drop zone
            const dropZone = document.getElementById('file-drop-zone');
            if (dropZone && dropZone.parentNode) {
                dropZone.parentNode.insertBefore(fileListContainer, dropZone.nextSibling);
            }
        }

        // Clear existing content
        fileListContainer.innerHTML = '';

        // Add header
        const header = document.createElement('div');
        header.className = 'files-header';
        header.innerHTML = `<h4>Selected Files (${this.selectedFiles.length}):</h4>`;
        fileListContainer.appendChild(header);

        // Add file items
        this.selectedFiles.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item-inline';
            fileItem.innerHTML = `
                <div class="file-info-inline">
                    <i class="fas fa-file-alt"></i>
                    <span class="file-name-inline">${file.name}</span>
                    <span class="file-size-inline">${this.formatFileSize(file.size)}</span>
                </div>
                <button class="remove-file-inline" onclick="app.removeFile(${index})" title="Remove file">
                    <i class="fas fa-times"></i>
                </button>
            `;
            fileListContainer.appendChild(fileItem);
        });
    }    removeFile(index) {
        this.selectedFiles.splice(index, 1);
        
        if (this.selectedFiles.length === 0) {
            // No files left, remove the file list and reset button text
            const fileListContainer = document.getElementById('selected-files-in-dropzone');
            if (fileListContainer) {
                fileListContainer.remove();
            }
            
            const uploadBtn = document.getElementById('generate-code-btn');
            if (uploadBtn) {
                uploadBtn.textContent = 'Upload Files';
            }
        } else {
            // Still have files, refresh the file display
            this.showSelectedFilesInDropZone();
        }
    }

    generateCode() {
        if (this.selectedFiles.length === 0) {
            this.showToast('Please select files first', 'warning');
            return;
        }

        this.socket.emit('generate-code');
        const generateButton = document.getElementById('generate-code-btn');
        if (generateButton) {
            generateButton.disabled = true;
            generateButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
        }
    }    handleCodeGenerated(data) {
        this.currentCode = data.code;
        
        // Hide the file list section and upload area
        const uploadArea = document.getElementById('upload-area');
        const selectedFiles = document.getElementById('selected-files');
        const selectedFilesSection = document.getElementById('selected-files-section');
        
        if (uploadArea) {
            uploadArea.classList.add('hidden');
            uploadArea.style.display = 'none';
        }
        
        if (selectedFiles) {
            selectedFiles.classList.add('hidden');
        }
        
        if (selectedFilesSection) {
            selectedFilesSection.classList.remove('hidden');
            selectedFilesSection.style.display = 'block';
            // Add a fade-in effect
            selectedFilesSection.style.animation = 'fadeIn 0.3s ease-in-out forwards';
        }
        
        // Update status message
        const statusMessage = document.getElementById('status-message');
        if (statusMessage) {
            statusMessage.textContent = 'Waiting for receiver...';
            statusMessage.className = 'status-waiting';
        }
        
        // Update the modern verification display with individual digits
        this.displayVerificationCode(data.code);
        
        // Show the selected files details
        this.showSelectedFileDetails();
        
        // Reset button
        const generateButton = document.getElementById('generate-code-btn');
        if (generateButton) {
            generateButton.disabled = false;
            generateButton.innerHTML = 'Upload Files';
        }
        
        this.showToast('Code generated successfully!', 'success');
    }

    async generateQRCode(code) {
        try {
            const response = await fetch(`http://localhost:5000/api/files/generate-qr/${code}`);
            const data = await response.json();
            
            const qrCodeImg = document.getElementById('qr-code-img');
            if (data.success && qrCodeImg) {
                qrCodeImg.src = data.qrCode;
            }
        } catch (error) {
            console.error('Error generating QR code:', error);
        }
    }    displayVerificationCode(code) {
        // Show the modern selected files section with the verification code
        const selectedFilesSection = document.getElementById('selected-files-section');
        if (selectedFilesSection) {
            selectedFilesSection.classList.remove('hidden');
        }
        
        // Get the verification code display element
        const codeDigitsContainer = document.getElementById('code-digits');
        
        if (codeDigitsContainer) {
            // Clear any existing digits
            codeDigitsContainer.innerHTML = '';
            
            // Create individual digit elements
            for (let i = 0; i < code.length; i++) {
                const digitElement = document.createElement('div');
                digitElement.className = 'code-digit';
                digitElement.textContent = code[i];
                codeDigitsContainer.appendChild(digitElement);
                
                // Add subtle animation
                digitElement.style.animation = `fadeIn 0.3s ease-in-out ${i * 0.1}s both`;
            }
        }    }
    
    showSelectedFileDetails() {
        console.log('Showing selected file details for', this.selectedFiles.length, 'files');
        
        // Show the selected files section
        const selectedFilesSection = document.getElementById('selected-files-section');
        if (!selectedFilesSection) {
            console.error('Selected files section element not found');
            return;
        }
        
        selectedFilesSection.classList.remove('hidden');
        console.log('Selected files section is now visible');
          // Initialize preview system
        this.currentFileIndex = 0;
        this.updateFilePreview();
        this.updateFileNavigation();
        this.addNavigationTooltips();
        
        // Update file details based on selection
        if (this.selectedFiles.length > 0) {
            // Primary file (first selected)
            const primaryFile = this.selectedFiles[0];
            console.log('Primary file:', primaryFile.name);
            
            let fileNameDisplay = primaryFile.name;
            let fileSizeTotal = primaryFile.size;
            
            // If multiple files, show count and calculate total size
            if (this.selectedFiles.length > 1) {
                fileNameDisplay = `${primaryFile.name} and ${this.selectedFiles.length - 1} more`;
                fileSizeTotal = this.selectedFiles.reduce((total, file) => total + file.size, 0);
            }
            
            // Determine primary file type or "Multiple" for mixed files
            let fileTypeDisplay = primaryFile.type || 'Unknown';
            if (this.selectedFiles.length > 1) {
                const uniqueTypes = new Set(this.selectedFiles.map(file => file.type || 'Unknown'));
                fileTypeDisplay = uniqueTypes.size > 1 ? 'Multiple formats' : fileTypeDisplay;
            }
            
            console.log('File details:', { fileNameDisplay, fileSizeTotal, fileTypeDisplay });
            
            // Update the file details
            const fileDetailName = document.getElementById('file-detail-name');
            const fileDetailSize = document.getElementById('file-detail-size');
            const fileDetailType = document.getElementById('file-detail-type');
            
            console.log('File detail elements:', { fileDetailName, fileDetailSize, fileDetailType });
            
            if (fileDetailName) {
                fileDetailName.textContent = fileNameDisplay;
                console.log('Updated file name:', fileNameDisplay);
            } else {
                console.error('File detail name element not found');
            }
            
            if (fileDetailSize) {
                fileDetailSize.textContent = this.formatFileSize(fileSizeTotal);
                console.log('Updated file size:', this.formatFileSize(fileSizeTotal));
            } else {
                console.error('File detail size element not found');
            }
            
            if (fileDetailType) {
                fileDetailType.textContent = fileTypeDisplay;
                console.log('Updated file type:', fileTypeDisplay);
            } else {
                console.error('File detail type element not found');
            }
        } else {
            console.warn('No selected files to display');
        }
    }

    // Force show selected files section for debugging
    forceShowSelectedFiles() {
        const selectedFilesSection = document.getElementById('selected-files-section');
        const uploadArea = document.getElementById('upload-area');
        
        console.log('Forcing show selected files section');
        
        if (uploadArea) {
            uploadArea.style.display = 'none';
            console.log('Upload area force hidden');
        }
        
        if (selectedFilesSection) {
            selectedFilesSection.classList.remove('hidden');
            selectedFilesSection.style.display = 'block';
            selectedFilesSection.style.visibility = 'visible';
            console.log('Selected files section force shown');
        }
        
        this.debugFileSelection();
    }

    copyCode() {
        if (this.currentCode) {
            navigator.clipboard.writeText(this.currentCode)
                .then(() => {
                    // Visual feedback
                    const btn = document.getElementById('copy-code-btn');
                    if (!btn) return;
                    
                    const originalText = btn.innerHTML;
                    
                    // Change button appearance
                    btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    btn.style.background = '#4CAF50';
                    btn.style.color = 'white';
                    
                    // Show toast
                    this.showToast('Code copied to clipboard!', 'success');
                    
                    // Reset the button after a delay
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.background = '';
                        btn.style.color = '';
                    }, 2000);
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.showToast('Failed to copy code', 'error');
                });
        }
    }

    joinTransfer() {
        const codeInput = document.getElementById('receive-code-input');
        if (!codeInput) return;
        
        const code = codeInput.value;
        
        if (code.length !== 6) {
            this.showToast('Please enter a 6-digit code', 'warning');
            return;
        }

        // Show file information if this is our own code (for self-transfer)
        if (this.currentCode === code && this.selectedFiles.length > 0) {
            this.showFilePreview();
        }

        this.isReceiver = true;
        this.socket.emit('join-room', { code });
        
        const receiveStatus = document.getElementById('receive-status');
        const receiveMessage = document.getElementById('receive-message');
        
        if (receiveStatus) receiveStatus.classList.remove('hidden');
        if (receiveMessage) {
            receiveMessage.textContent = 'Connecting...';
            receiveMessage.className = 'status-waiting';
        }
    }    handleReceiverJoined(data) {
        console.log(`Receiver joined: ${data.receiverSocketId}, my socket ID: ${this.socket.id}`);
        const statusMessage = document.getElementById('status-message');
        if (statusMessage) {
            statusMessage.textContent = 'Receiver connected! Establishing connection...';
            statusMessage.className = 'status-connected';
        }
        
        // Check if this is a self-connection (same socket)
        if (data.receiverSocketId === this.socket.id) {
            console.log('Self-connection detected, simulating local transfer');
            // Self-connection: simulate local transfer
            this.simulateLocalTransfer();
        } else {
            console.log(`Initiating P2P connection to receiver: ${data.receiverSocketId}`);
            // Initialize peer connection as initiator (sender)
            this.initPeerConnection(true, data.receiverSocketId);
        }
        
        this.showToast('Receiver joined! Starting transfer...', 'success');
    }    handleJoinedRoom(data) {
        console.log(`Joined room with sender: ${data.senderSocketId}, my socket ID: ${this.socket.id}`);
        const receiveMessage = document.getElementById('receive-message');
        if (receiveMessage) {
            receiveMessage.textContent = 'Connected! Waiting for files...';
            receiveMessage.className = 'status-connected';
        }
        
        // Check if this is a self-connection (same socket)
        if (data.senderSocketId === this.socket.id) {
            console.log('Self-connection detected, simulating local transfer');
            // Self-connection: simulate local transfer
            this.simulateLocalTransfer();
        } else {
            console.log(`Initiating P2P connection to sender: ${data.senderSocketId}`);
            // Initialize peer connection as non-initiator (receiver)
            this.initPeerConnection(false, data.senderSocketId);
        }
        
        this.showToast('Connected to sender!', 'success');
    }    initPeerConnection(initiator, targetSocketId) {
        console.log(`Initializing peer connection - Initiator: ${initiator}, Target: ${targetSocketId}, My ID: ${this.socket.id}`);
        
        this.peer = new SimplePeer({
            initiator: initiator,
            trickle: false
        });

        this.peer.on('signal', (signal) => {
            console.log(`Sending signal to ${targetSocketId}`);
            this.socket.emit('signal', {
                to: targetSocketId,
                signal: signal
            });
        });

        this.peer.on('connect', () => {
            console.log('P2P connection established with', targetSocketId);
            this.showToast('P2P connection established!', 'success');
            
            if (initiator) {
                // Sender: start sending files
                console.log('Starting file transfer as sender');
                this.sendFiles();
            } else {
                console.log('Ready to receive files');
            }
        });

        this.peer.on('data', (data) => {
            this.handleIncomingData(data);
        });

        this.peer.on('error', (err) => {
            console.error('Peer connection error:', err);
            this.showToast('Connection failed. Please try again.', 'error');
        });
    }    handleSignal(data) {
        console.log(`Received signal from ${data.from}`);
        if (this.peer) {
            this.peer.signal(data.signal);
        } else {
            console.warn('Received signal but no peer connection exists');
        }
    }

    sendFiles() {
        if (!this.peer || !this.selectedFiles.length) return;

        const statusMessage = document.getElementById('status-message');
        const progressBar = document.getElementById('progress-bar');
        
        if (statusMessage) {
            statusMessage.textContent = 'Sending files...';
            statusMessage.className = 'status-transferring';
        }
        
        if (progressBar) {
            progressBar.classList.remove('hidden');
        }

        let fileIndex = 0;
        let totalSize = this.selectedFiles.reduce((sum, file) => sum + file.size, 0);
        let sentSize = 0;

        const sendNextFile = () => {
            if (fileIndex >= this.selectedFiles.length) {
                // All files sent
                this.peer.send(JSON.stringify({ type: 'complete' }));
                this.handleTransferComplete();
                return;
            }

            const file = this.selectedFiles[fileIndex];
            const chunkSize = 16384; // 16KB chunks
            let offset = 0;

            // Send file metadata
            this.peer.send(JSON.stringify({
                type: 'file-start',
                name: file.name,
                size: file.size,
                type: file.type
            }));

            const sendChunk = () => {
                const reader = new FileReader();
                const slice = file.slice(offset, offset + chunkSize);

                reader.onload = (e) => {
                    this.peer.send(e.target.result);
                    offset += chunkSize;
                    sentSize += Math.min(chunkSize, file.size - (offset - chunkSize));

                    // Update progress
                    const progress = (sentSize / totalSize) * 100;
                    const progressFill = document.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = progress + '%';
                    }

                    if (offset < file.size) {
                        sendChunk();
                    } else {
                        // File complete
                        this.peer.send(JSON.stringify({ type: 'file-end' }));
                        fileIndex++;
                        sendNextFile();
                    }
                };

                reader.readAsArrayBuffer(slice);
            };

            sendChunk();
        };

        sendNextFile();
    }

    handleIncomingData(data) {
        try {
            // Try to parse as JSON (metadata)
            const message = JSON.parse(data);
            
            const receiveMessage = document.getElementById('receive-message');
            const receiveProgressBar = document.getElementById('receive-progress-bar');
            
            switch (message.type) {
                case 'file-start':
                    this.currentReceivingFile = {
                        name: message.name,
                        size: message.size,
                        type: message.type,
                        chunks: []
                    };
                    
                    if (receiveMessage) {
                        receiveMessage.textContent = `Receiving: ${message.name}`;
                        receiveMessage.className = 'status-transferring';
                    }
                    
                    if (receiveProgressBar) {
                        receiveProgressBar.classList.remove('hidden');
                    }
                    break;
                
                case 'file-end':
                    this.completeFileReceive();
                    break;
                
                case 'complete':
                    this.handleReceiveComplete();
                    break;
            }
        } catch (e) {
            // Binary data (file chunk)
            if (this.currentReceivingFile) {
                this.currentReceivingFile.chunks.push(data);
                
                // Update progress
                const received = this.currentReceivingFile.chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
                const progress = (received / this.currentReceivingFile.size) * 100;
                
                const progressFill = document.querySelector('#receive-progress-bar .progress-fill');
                if (progressFill) {
                    progressFill.style.width = progress + '%';
                }
            }
        }
    }

    completeFileReceive() {
        if (!this.currentReceivingFile) return;

        // Combine all chunks
        const totalSize = this.currentReceivingFile.chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
        const combinedArray = new Uint8Array(totalSize);
        let offset = 0;

        this.currentReceivingFile.chunks.forEach(chunk => {
            combinedArray.set(new Uint8Array(chunk), offset);
            offset += chunk.byteLength;
        });

        // Create blob and download link
        const blob = new Blob([combinedArray], { type: this.currentReceivingFile.type });
        const file = {
            name: this.currentReceivingFile.name,
            size: this.currentReceivingFile.size,
            blob: blob,
            url: URL.createObjectURL(blob)
        };

        this.receivedFiles.push(file);
        this.displayReceivedFile(file);
        
        this.currentReceivingFile = null;
    }

    displayReceivedFile(file) {
        const receivedFilesDiv = document.getElementById('received-files');
        const fileList = document.getElementById('received-file-list');
        
        if (!receivedFilesDiv || !fileList) return;
        
        // Check if file already exists in both the display and receivedFiles array
        const existsInArray = this.receivedFiles.some(existingFile => 
            existingFile.name === file.name && existingFile.size === file.size
        );
        
        const existsInDisplay = Array.from(fileList.querySelectorAll('.file-name'))
            .some(element => element.textContent === file.name);
        
        if (existsInArray && existsInDisplay) {
            console.log('File already displayed:', file.name);
            return; // File already displayed, don't add again
        }
        
        receivedFilesDiv.classList.remove('hidden');
        
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
            <div class="file-info">
                <i class="fas fa-file"></i>
                <span class="file-name">${file.name}</span>
                <span class="file-size">(${this.formatFileSize(file.size)})</span>
            </div>
            <a href="${file.url}" download="${file.name}" class="btn btn-primary">
                <i class="fas fa-download"></i> Download
            </a>
        `;
        fileList.appendChild(fileItem);
        
        // Show download all button if there are multiple files
        const downloadAllBtn = document.getElementById('download-all-btn');
        if (this.receivedFiles.length > 1 && downloadAllBtn) {
            downloadAllBtn.classList.remove('hidden');
        }
    }

    handleTransferComplete() {
        const statusMessage = document.getElementById('status-message');
        if (statusMessage) {
            statusMessage.textContent = 'Transfer completed successfully!';
            statusMessage.className = 'status-completed';
        }
        
        this.showToast('Files sent successfully!', 'success');
        
        // Log transfer stats
        const totalSize = this.selectedFiles.reduce((sum, file) => sum + file.size, 0);
        fetch('http://localhost:5000/api/files/log-transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                code: this.currentCode,
                fileCount: this.selectedFiles.length,
                totalSize: totalSize
            })
        }).catch(console.error);
    }

    handleReceiveComplete() {
        const receiveMessage = document.getElementById('receive-message');
        if (receiveMessage) {
            receiveMessage.textContent = 'All files received successfully!';
            receiveMessage.className = 'status-completed';
        }
        
        this.showToast(`Received ${this.receivedFiles.length} files successfully!`, 'success');
    }

    simulateLocalTransfer() {
        // For self-connections, directly transfer files locally
        if (!this.selectedFiles || this.selectedFiles.length === 0) {
            this.showToast('No files selected for transfer', 'error');
            return;
        }

        // Clear any existing received files to prevent duplicates
        this.clearReceivedFiles();

        const statusMessage = document.getElementById('status-message');
        const progressBar = document.getElementById('progress-bar');
        const receiveMessage = document.getElementById('receive-message');
        const receiveProgressBar = document.getElementById('receive-progress-bar');
        
        if (statusMessage) {
            statusMessage.textContent = 'Transferring files locally...';
            statusMessage.className = 'status-transferring';
        }
        
        if (progressBar) {
            progressBar.classList.remove('hidden');
        }
        
        if (receiveMessage) {
            receiveMessage.textContent = 'Receiving files...';
            receiveMessage.className = 'status-transferring';
        }
        
        if (receiveProgressBar) {
            receiveProgressBar.classList.remove('hidden');
        }

        // Simulate transfer with progress
        let progress = 0;
        const interval = setInterval(() => {
            progress += 10;
            
            const progressFill = document.querySelector('.progress-fill');
            const receiveProgressFill = document.querySelector('#receive-progress-bar .progress-fill');
            
            if (progressFill) {
                progressFill.style.width = progress + '%';
            }
            
            if (receiveProgressFill) {
                receiveProgressFill.style.width = progress + '%';
            }

            if (progress >= 100) {
                clearInterval(interval);
                  // Process each file only once
                this.selectedFiles.forEach(file => {
                    const fileObj = {
                        name: file.name,
                        size: file.size,
                        blob: file,
                        url: URL.createObjectURL(file)
                    };
                    
                    // Add to receivedFiles array only if not already present
                    const exists = this.receivedFiles.some(existingFile => 
                        existingFile.name === file.name && existingFile.size === file.size
                    );
                    
                    if (!exists) {
                        this.receivedFiles.push(fileObj);
                    }
                    
                    // Display the file (displayReceivedFile will handle duplicates)
                    this.displayReceivedFile(fileObj);
                });

                // Complete the transfer
                this.handleTransferComplete();
                this.handleReceiveComplete();
            }
        }, 200);
    }    resetTransfer() {
        // Clear received files display
        this.clearReceivedFiles();
        
        // Show upload area again and hide file details
        const uploadArea = document.getElementById('upload-area');
        const selectedFilesSection = document.getElementById('selected-files-section');
        const dropZone = document.getElementById('file-drop-zone');
        
        if (uploadArea) {
            uploadArea.classList.remove('hidden');
            uploadArea.style.display = 'block';
            uploadArea.style.animation = 'fadeIn 0.4s ease-out';
        }
        
        if (dropZone) {
            // Reset drop zone appearance
            dropZone.classList.remove('drag-over');
        }        if (selectedFilesSection) {
            selectedFilesSection.classList.add('hidden');
            selectedFilesSection.style.display = 'none';
        }
        
        // Clear inline file display from drop zone area
        const inlineFileContainer = document.getElementById('selected-files-in-dropzone');
        if (inlineFileContainer) {
            inlineFileContainer.remove();
        }
        
        // Reset old UI elements (keeping them hidden)
        const elements = [
            'selected-files', 'transfer-code', 'receive-status', 
            'progress-bar', 'receive-progress-bar', 'transfer-actions', 
            'cancel-receive-btn', 'download-all-btn', 'reset-actions'
        ];
        
        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element) element.classList.add('hidden');
        });
          // Clear data
        this.selectedFiles = [];
        this.currentCode = null;
        this.receivedFiles = [];
        this.currentReceivingFile = null;
        
        // Reset inputs
        const fileInput = document.getElementById('file-input');
        const receiveCodeInput = document.getElementById('receive-code-input');
        
        if (fileInput) fileInput.value = '';
        if (receiveCodeInput) receiveCodeInput.value = '';
          // Reset the upload button text back to "Upload Files" (default state)
        const uploadBtn = document.getElementById('generate-code-btn');
        if (uploadBtn) {
            uploadBtn.textContent = 'Upload Files';
        }
        
        // Reset progress bars
        document.querySelectorAll('.progress-fill').forEach(bar => {
            bar.style.width = '0%';
        });
        
        this.showToast('Transfer reset successfully', 'info');
    }clearReceivedFiles() {
        // Clear the received files list UI
        const fileList = document.getElementById('received-file-list');
        if (fileList) {
            fileList.innerHTML = '';
        }
        
        // Hide received files section
        const receivedFiles = document.getElementById('received-files');
        const downloadAllBtn = document.getElementById('download-all-btn');
        
        if (receivedFiles) receivedFiles.classList.add('hidden');
        if (downloadAllBtn) downloadAllBtn.classList.add('hidden');
        
        // Revoke object URLs to free memory
        this.receivedFiles.forEach(file => {
            if (file.url) {
                URL.revokeObjectURL(file.url);
            }
        });
        
        // Clear the array
        this.receivedFiles = [];
    }

    cancelTransfer() {
        if (this.peer) {
            this.peer.destroy();
            this.peer = null;
        }
        
        // Update status
        const statusMessage = document.getElementById('status-message');
        const transferActions = document.getElementById('transfer-actions');
        
        if (statusMessage) {
            statusMessage.textContent = 'Transfer cancelled';
            statusMessage.className = 'status-error';
        }
        
        // Show reset option
        if (transferActions) {
            transferActions.classList.remove('hidden');
        }
        
        this.showToast('Transfer cancelled', 'warning');
    }

    cancelReceive() {
        if (this.peer) {
            this.peer.destroy();
            this.peer = null;
        }
        
        // Update status
        const receiveMessage = document.getElementById('receive-message');
        if (receiveMessage) {
            receiveMessage.textContent = 'Receive cancelled';
            receiveMessage.className = 'status-error';
        }
        
        this.clearReceivedFiles();
        this.showToast('Receive cancelled', 'warning');
    }

    downloadAllFiles() {
        if (this.receivedFiles.length === 0) {
            this.showToast('No files to download', 'warning');
            return;
        }
        
        this.receivedFiles.forEach(file => {
            const link = document.createElement('a');
            link.href = file.url;
            link.download = file.name;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
        
        this.showToast(`Downloaded ${this.receivedFiles.length} files`, 'success');
    }

    // QR Code Scanner
    startQRScanner() {
        const video = document.getElementById('camera-video');
        const canvas = document.getElementById('camera-canvas');
        const cameraSection = document.getElementById('camera-section');
        
        if (!video || !canvas || !cameraSection) return;
        
        const context = canvas.getContext('2d');
        
        cameraSection.classList.remove('hidden');
        
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(stream => {
                video.srcObject = stream;
                this.scanQRCode(video, canvas, context);
            })
            .catch(err => {
                console.error('Error accessing camera:', err);
                this.showToast('Unable to access camera', 'error');
            });
    }

    scanQRCode(video, canvas, context) {
        const scan = () => {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                if (code) {
                    // Extract code from URL
                    const match = code.data.match(/\/receive\/(\d{6})/);
                    if (match) {
                        const receiveCodeInput = document.getElementById('receive-code-input');
                        if (receiveCodeInput) {
                            receiveCodeInput.value = match[1];
                        }
                        this.stopQRScanner();
                        this.showToast('QR code scanned successfully!', 'success');
                        return;
                    }
                }
            }
            
            const cameraSection = document.getElementById('camera-section');
            if (cameraSection && !cameraSection.classList.contains('hidden')) {
                requestAnimationFrame(scan);
            }
        };
        
        scan();
    }

    stopQRScanner() {
        const video = document.getElementById('camera-video');
        const cameraSection = document.getElementById('camera-section');
        
        if (!video || !cameraSection) return;
        
        const stream = video.srcObject;
        
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        
        cameraSection.classList.add('hidden');
    }

    // Utility functions
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toast-container');
        if (!toastContainer) return;
        
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        
        // Different icons based on toast type
        let icon = 'info-circle';
        switch(type) {
            case 'success': icon = 'check-circle'; break;
            case 'error': icon = 'exclamation-circle'; break;
            case 'warning': icon = 'exclamation-triangle'; break;
        }
        
        toast.innerHTML = `
            <div class="toast-icon">
                <i class="fas fa-${icon}"></i>
            </div>
            <div class="toast-content">
                <p>${message}</p>
            </div>
        `;
        
        toastContainer.appendChild(toast);
        
        // Animate entry
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        // Auto remove
        setTimeout(() => {
            toast.classList.remove('show');
            toast.classList.add('hide');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }

    showFilePreview() {
        // Show preview of files that will be received
        const receiveMessage = document.getElementById('receive-message');
        const receiveStatus = document.getElementById('receive-status');
        
        if (!receiveMessage || !receiveStatus) return;
        
        receiveStatus.classList.remove('hidden');
        
        // Create a preview section
        let previewSection = document.getElementById('file-preview');
        if (!previewSection) {
            previewSection = document.createElement('div');
            previewSection.id = 'file-preview';
            previewSection.className = 'file-preview';
            receiveStatus.appendChild(previewSection);
        }
        
        previewSection.innerHTML = `
            <h4>Files to be received (${this.selectedFiles.length}):</h4>
            <div class="preview-file-list">
                ${this.selectedFiles.map(file => `
                    <div class="preview-file-item">
                        <i class="fas fa-file"></i>
                        <span class="file-name">${file.name}</span>
                        <span class="file-size">(${this.formatFileSize(file.size)})</span>
                    </div>
                `).join('')}
            </div>
            <div class="total-size">
                Total size: ${this.formatFileSize(this.selectedFiles.reduce((sum, file) => sum + file.size, 0))}
            </div>
        `;
    }

    // Debug helper method for testing
    debugFileSelection() {
        console.log('=== File Selection Debug Info ===');
        console.log('Selected files count:', this.selectedFiles.length);
        console.log('Selected files:', this.selectedFiles.map(f => ({ name: f.name, size: f.size, type: f.type })));
        
        const uploadArea = document.getElementById('upload-area');
        const selectedFilesSection = document.getElementById('selected-files-section');
        const fileDetailName = document.getElementById('file-detail-name');
        const fileDetailSize = document.getElementById('file-detail-size');
        const fileDetailType = document.getElementById('file-detail-type');
        
        console.log('DOM Elements:');
        console.log('- Upload area:', uploadArea, uploadArea?.classList.toString());
        console.log('- Selected files section:', selectedFilesSection, selectedFilesSection?.classList.toString());
        console.log('- File detail name:', fileDetailName, fileDetailName?.textContent);
        console.log('- File detail size:', fileDetailSize, fileDetailSize?.textContent);        console.log('- File detail type:', fileDetailType, fileDetailType?.textContent);
        console.log('================================');
    }
    
    // File Preview Methods
    updateFilePreview() {
        if (this.selectedFiles.length === 0) return;
        
        const currentFile = this.selectedFiles[this.currentFileIndex];
        if (!currentFile) return;
        
        // Update file counter
        const currentFileInfo = document.getElementById('current-file-info');
        if (currentFileInfo) {
            currentFileInfo.textContent = `File ${this.currentFileIndex + 1} of ${this.selectedFiles.length}`;
        }
        
        // Show loading state
        this.showPreviewLoading();
        
        // Generate preview based on file type
        this.generatePreview(currentFile);
    }
    
    updateFileNavigation() {
        const prevFileBtn = document.getElementById('prev-file-btn');
        const nextFileBtn = document.getElementById('next-file-btn');
        
        if (prevFileBtn) {
            prevFileBtn.disabled = this.currentFileIndex <= 0;
        }
        
        if (nextFileBtn) {
            nextFileBtn.disabled = this.currentFileIndex >= this.selectedFiles.length - 1;
        }
    }
      // Page navigation update with enhanced animations
    updatePageNavigation() {
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const pageInfo = document.getElementById('page-info');
        const pageNavControls = document.getElementById('page-nav-controls');
        
        // Update page navigation buttons with smooth state transitions
        if (prevPageBtn) {
            const wasDisabled = prevPageBtn.disabled;
            prevPageBtn.disabled = this.currentPageIndex <= 0;
            
            // Add visual feedback for state change
            if (wasDisabled !== prevPageBtn.disabled) {
                prevPageBtn.style.transition = 'all 0.3s ease';
            }
        }
        
        if (nextPageBtn) {
            const wasDisabled = nextPageBtn.disabled;
            nextPageBtn.disabled = this.currentPageIndex >= this.totalPages - 1;
            
            // Add visual feedback for state change
            if (wasDisabled !== nextPageBtn.disabled) {
                nextPageBtn.style.transition = 'all 0.3s ease';
            }
        }
        
        // Update page info display with animation
        if (pageInfo) {
            const newText = `Page ${this.currentPageIndex + 1} of ${this.totalPages}`;
            
            // Only animate if the text actually changed
            if (pageInfo.textContent !== newText) {
                pageInfo.classList.add('changing');
                
                // Update text after brief delay for smooth transition
                setTimeout(() => {
                    pageInfo.textContent = newText;
                }, 150);
                
                // Remove animation class
                setTimeout(() => {
                    pageInfo.classList.remove('changing');
                }, 450);
            }
        }
        
        // Show/hide page navigation controls with enhanced animations
        if (pageNavControls) {
            const shouldShow = this.totalPages > 1;
            const isCurrentlyVisible = !pageNavControls.classList.contains('hidden');
            
            if (shouldShow && !isCurrentlyVisible) {
                // Show with pulse animation
                pageNavControls.classList.remove('hidden');
                pageNavControls.classList.add('pulse');
                
                // Remove pulse class after animation
                setTimeout(() => {
                    pageNavControls.classList.remove('pulse');
                }, 600);
                
            } else if (!shouldShow && isCurrentlyVisible) {
                // Hide with fade out
                pageNavControls.style.opacity = '0';
                pageNavControls.style.transform = 'translateX(-50%) translateY(10px)';
                
                setTimeout(() => {
                    pageNavControls.classList.add('hidden');
                    pageNavControls.style.opacity = '';
                    pageNavControls.style.transform = '';
                }, 300);
            }
        }
    }
    
    // Enhanced navigation with visual feedback
    navigateToFile(newIndex) {
        if (newIndex < 0 || newIndex >= this.selectedFiles.length) return;
        
        // Add visual transition
        const previewContent = document.getElementById('preview-content');
        if (previewContent) {
            previewContent.style.opacity = '0.5';
            previewContent.style.transform = 'scale(0.95)';
        }
        
        setTimeout(() => {
            this.currentFileIndex = newIndex;
            this.currentPageIndex = 0;
            this.updateFilePreview();
            this.updateFileNavigation();
            
            // Restore visual state
            if (previewContent) {
                previewContent.style.opacity = '1';
                previewContent.style.transform = 'scale(1)';
            }
            
            // Show brief file indicator
            this.showFileIndicator();
        }, 150);
    }
      navigateToPage(newPageIndex) {
        if (newPageIndex < 0 || newPageIndex >= this.totalPages) return;
        
        // Add loading state to page navigation
        const pageNavControls = document.getElementById('page-nav-controls');
        const previewContent = document.getElementById('preview-content');
        
        if (pageNavControls) {
            pageNavControls.classList.add('loading');
        }
        
        // Add visual transition for page navigation
        if (previewContent) {
            previewContent.style.opacity = '0.7';
            previewContent.style.transform = 'scale(0.98)';
            previewContent.style.transition = 'all 0.2s ease';
        }
        
        setTimeout(() => {
            this.currentPageIndex = newPageIndex;
            this.updatePagePreview();
            this.updatePageNavigation();
            
            // Remove loading state and restore visual state
            if (pageNavControls) {
                pageNavControls.classList.remove('loading');
            }
            
            if (previewContent) {
                previewContent.style.opacity = '1';
                previewContent.style.transform = 'scale(1)';
                
                // Clean up inline styles after transition
                setTimeout(() => {
                    previewContent.style.transition = '';
                    previewContent.style.transform = '';
                }, 200);
            }
        }, 150);
    }
    
    // Show a brief indicator when switching files
    showFileIndicator() {
        const currentFile = this.selectedFiles[this.currentFileIndex];
        if (!currentFile) return;
        
        // Create or update file indicator
        let indicator = document.getElementById('file-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'file-indicator';
            indicator.className = 'file-indicator';
            document.body.appendChild(indicator);
        }
        
        indicator.innerHTML = `
            <div class="indicator-content">
                <i class="fas fa-file"></i>
                <span>${currentFile.name}</span>
                <small>${this.currentFileIndex + 1} of ${this.selectedFiles.length}</small>
            </div>
        `;
        
        // Show with animation
        indicator.classList.add('show');
        
        // Auto hide after 2 seconds
        setTimeout(() => {
            indicator.classList.remove('show');
        }, 2000);
    }
    
    generatePreview(file) {
        const previewContent = document.getElementById('preview-content');
        const previewTypeInfo = document.getElementById('preview-type-info');
        
        if (!previewContent) return;
        
        const fileType = this.getFileType(file);
          switch (fileType) {            case 'image':
                this.createImagePreview(file, previewContent);
                if (previewTypeInfo) previewTypeInfo.textContent = '';
                break;            case 'video':
                this.createVideoPreview(file, previewContent);
                if (previewTypeInfo) previewTypeInfo.textContent = '';
                break;case 'pdf':
                this.createPDFPreview(file, previewContent);
                if (previewTypeInfo) previewTypeInfo.textContent = '';
                break;            case 'document':
                this.createDocumentPreview(file, previewContent);
                const extension = file.name.split('.').pop()?.toLowerCase();
                if (['txt', 'rtf'].includes(extension)) {
                    if (previewTypeInfo) previewTypeInfo.textContent = '';
                } else {
                    if (previewTypeInfo) previewTypeInfo.textContent = '';
                }
                break;
            default:
                this.createFileIcon(file, previewContent);
                if (previewTypeInfo) previewTypeInfo.textContent = '';
        }
    }
      getFileType(file) {
        const extension = file.name.split('.').pop()?.toLowerCase();
        const mimeType = file.type?.toLowerCase();
        
        // Image files
        if (mimeType?.startsWith('image/') || ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'].includes(extension)) {
            return 'image';
        }
        
        // Video files
        if (mimeType?.startsWith('video/') || ['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv'].includes(extension)) {
            return 'video';
        }
        
        // PDF files
        if (mimeType === 'application/pdf' || extension === 'pdf') {
            return 'pdf';
        }
        
        // Document files (including MIME type detection)
        const documentExtensions = ['doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'txt', 'rtf'];
        const documentMimeTypes = [
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/vnd.ms-powerpoint',
            'application/vnd.openxmlformats.officedocument.presentationml.presentation',
            'application/vnd.ms-excel',
            'application/vnd.openxmlformats.officedocument.spreadsheetml.sheet',
            'text/plain',
            'application/rtf'
        ];
        
        if (documentExtensions.includes(extension) || documentMimeTypes.some(type => mimeType?.includes(type))) {
            return 'document';
        }
        
        return 'other';
    }
    
    createImagePreview(file, container) {
        const url = URL.createObjectURL(file);
        container.innerHTML = `<img src="${url}" class="image-preview" alt="${file.name}">`;
        
        // Clean up URL when image loads
        const img = container.querySelector('img');
        img.onload = () => URL.revokeObjectURL(url);
        
        this.totalPages = 1;
        this.updatePageNavigation();
    }
    
    createVideoPreview(file, container) {
        const url = URL.createObjectURL(file);
        container.innerHTML = `
            <video class="video-preview" controls preload="metadata">
                <source src="${url}" type="${file.type}">
                Your browser does not support the video tag.
            </video>
        `;
        
        this.totalPages = 1;
        this.updatePageNavigation();
        
        // Show fullscreen button
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        if (fullscreenBtn) fullscreenBtn.classList.remove('hidden');
    }      createPDFPreview(file, container) {
        console.log('Creating PDF preview for:', file.name);
        console.log('PDF.js available:', typeof pdfjsLib !== 'undefined');
          if (typeof pdfjsLib === 'undefined') {
            console.error('PDF.js not loaded, using fallback preview');
            alert('PDF preview may not work properly - PDF.js library not loaded');
            this.createFallbackPDFPreview(file, container);
            return;
        }
        
        console.log('PDF.js version:', pdfjsLib.version);
        
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                console.log('PDF file read, size:', e.target.result.byteLength);
                const typedArray = new Uint8Array(e.target.result);
                console.log('Loading PDF document...');                const loadingTask = pdfjsLib.getDocument({
                    data: typedArray,
                    cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                    cMapPacked: true
                });
                
                const pdf = await loadingTask.promise;
                console.log('PDF loaded successfully, pages:', pdf.numPages);
                
                this.totalPages = pdf.numPages;
                this.previewData = pdf;
                
                await this.renderPDFPage(1, container);
                this.updatePageNavigation();            } catch (error) {
                console.error('Error loading PDF:', error);
                console.log('PDF.js failed, trying fallback preview');
                this.createFallbackPDFPreview(file, container);
            }
        };
        
        reader.onerror = (error) => {
            console.error('Error reading PDF file:', error);
            container.innerHTML = `
                <div class="preview-error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>Error reading PDF file</p>
                    <small>File may be corrupted</small>
                </div>
            `;
        };
        
        reader.readAsArrayBuffer(file);
    }
      // Fallback PDF preview using browser's built-in PDF viewer
    createFallbackPDFPreview(file, container) {
        console.log('Creating fallback PDF preview');
        const url = URL.createObjectURL(file);
        
        // Try iframe first
        container.innerHTML = `
            <div class="pdf-fallback-container">
                <iframe 
                    src="${url}" 
                    class="pdf-iframe"
                    title="PDF Preview: ${file.name}"
                >
                    <!-- Fallback for browsers that don't support iframe PDF -->
                    <div class="pdf-fallback-message">
                        <i class="fas fa-file-pdf"></i>
                        <p>PDF preview not available</p>
                        <p><strong>${file.name}</strong></p>
                        <p>${this.formatFileSize(file.size)}</p>
                        <button onclick="window.open('${url}', '_blank')" class="btn-preview-action">
                            <i class="fas fa-external-link-alt"></i> Open in New Tab
                        </button>
                    </div>
                </iframe>
            </div>
        `;
        
        // Clean up URL after some time
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 30000);
        
        this.totalPages = 1; // We can't determine page count with iframe
        this.updatePageNavigation();
    }
      async renderPDFPage(pageNum, container) {
        if (!this.previewData) {
            console.error('No PDF data available for rendering');
            return;
        }
        
        try {
            console.log(`Rendering PDF page ${pageNum}...`);
            const page = await this.previewData.getPage(pageNum);
            
            // Calculate scale to fit container
            const containerWidth = container.clientWidth || 800;
            const containerHeight = container.clientHeight || 600;
            let scale = Math.min(containerWidth / page.getViewport({ scale: 1 }).width, 1.5);
            
            const viewport = page.getViewport({ scale });
            console.log('PDF viewport:', viewport.width, 'x', viewport.height, 'scale:', scale);
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.className = 'document-canvas';
            canvas.style.maxWidth = '100%';
            canvas.style.height = 'auto';
            
            container.innerHTML = '';
            container.appendChild(canvas);
            
            const renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            
            console.log('Starting PDF page render...');
            await page.render(renderContext).promise;
            console.log('PDF page rendered successfully');
            
        } catch (error) {
            console.error('Error rendering PDF page:', error);
            container.innerHTML = `
                <div class="preview-error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>Error rendering PDF page ${pageNum}</p>
                    <small>${error.message}</small>
                </div>
            `;
        }
    }
    
    async updatePagePreview() {
        const previewContent = document.getElementById('preview-content');
        if (!previewContent || !this.previewData) return;
        
        const currentFile = this.selectedFiles[this.currentFileIndex];
        const fileType = this.getFileType(currentFile);
        
        if (fileType === 'pdf') {
            await this.renderPDFPage(this.currentPageIndex + 1, previewContent);
        }
    }
      createDocumentPreview(file, container) {
        const extension = file.name.split('.').pop()?.toLowerCase();
        
        // Try to read document content for text-based formats
        if (['txt', 'rtf'].includes(extension)) {
            this.createTextPreview(file, container);
            return;
        }
        
        // For office documents, show enhanced preview
        this.createEnhancedDocumentPreview(file, container);
    }
    
    createTextPreview(file, container) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            const truncatedContent = content.length > 1000 ? content.substring(0, 1000) + '...' : content;
            
            container.innerHTML = `
                <div class="text-preview">
                    <div class="text-content">
                        <pre>${this.escapeHtml(truncatedContent)}</pre>
                    </div>
                    ${content.length > 1000 ? '<div class="text-info">Content truncated for preview</div>' : ''}
                </div>
            `;
        };
        reader.readAsText(file);
        
        this.totalPages = 1;
        this.updatePageNavigation();
    }
    
    createEnhancedDocumentPreview(file, container) {
        const extension = file.name.split('.').pop()?.toLowerCase();
        let documentType, iconClass, documentInfo;
        
        switch (extension) {
            case 'doc':
            case 'docx':
                documentType = 'Microsoft Word Document';
                iconClass = 'fa-file-word';
                documentInfo = 'Word processing document with text, images, and formatting';
                break;
            case 'ppt':
            case 'pptx':
                documentType = 'Microsoft PowerPoint Presentation';
                iconClass = 'fa-file-powerpoint';
                documentInfo = 'Presentation with slides, text, images, and animations';
                break;
            case 'xls':
            case 'xlsx':
                documentType = 'Microsoft Excel Spreadsheet';
                iconClass = 'fa-file-excel';
                documentInfo = 'Spreadsheet with data, formulas, and charts';
                break;
            default:
                documentType = 'Document';
                iconClass = 'fa-file';
                documentInfo = 'Document file';
        }
        
        container.innerHTML = `
            <div class="enhanced-document-preview">
                <div class="document-icon-large">
                    <i class="fas ${iconClass}"></i>
                </div>
                <div class="document-details">
                    <h3 class="document-title">${file.name}</h3>
                    <p class="document-type">${documentType}</p>
                    <p class="document-size">${this.formatFileSize(file.size)}</p>
                    <p class="document-description">${documentInfo}</p>
                </div>
                <div class="document-actions">
                    <button class="btn-preview-action" onclick="app.tryOfficeOnlinePreview('${file.name}')">
                        <i class="fas fa-eye"></i> Try Online Preview
                    </button>
                    <button class="btn-preview-action" onclick="app.showDocumentInfo('${file.name}')">
                        <i class="fas fa-info-circle"></i> File Properties
                    </button>
                </div>
                <div class="preview-limitation">
                    <i class="fas fa-info-circle"></i>
                    <span>Full document preview requires download or online service</span>
                </div>
            </div>
        `;
        
        this.totalPages = 1;
        this.updatePageNavigation();
    }
    
    createFileIcon(file, container) {
        const extension = file.name.split('.').pop()?.toLowerCase();
        let iconClass = 'fa-file';
        
        // Set appropriate icon based on file type
        if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(extension)) {
            iconClass = 'fa-file-image';
        } else if (['mp4', 'avi', 'mov', 'wmv'].includes(extension)) {
            iconClass = 'fa-file-video';
        } else if (['mp3', 'wav', 'flac', 'aac'].includes(extension)) {
            iconClass = 'fa-file-audio';
        } else if (['pdf'].includes(extension)) {
            iconClass = 'fa-file-pdf';
        } else if (['doc', 'docx'].includes(extension)) {
            iconClass = 'fa-file-word';
        } else if (['xls', 'xlsx'].includes(extension)) {
            iconClass = 'fa-file-excel';
        } else if (['ppt', 'pptx'].includes(extension)) {
            iconClass = 'fa-file-powerpoint';
        } else if (['zip', 'rar', '7z'].includes(extension)) {
            iconClass = 'fa-file-archive';
        }
        
        container.innerHTML = `
            <div class="file-type-icon">
                <i class="fas ${iconClass}"></i>
                <div class="file-name">${file.name}</div>
                <div class="file-info">${this.formatFileSize(file.size)}</div>
            </div>
        `;
        
        this.totalPages = 1;
        this.updatePageNavigation();
    }
    
    showPreviewLoading() {
        const previewContent = document.getElementById('preview-content');
        if (previewContent) {
            previewContent.innerHTML = `
                <div class="preview-loading">
                    <div class="spinner"></div>
                    <span>Loading preview...</span>
                </div>
            `;
        }
    }
    
    toggleFullscreen() {
        const previewContainer = document.querySelector('.preview-container');
        if (!previewContainer) return;
        
        if (!document.fullscreenElement) {
            previewContainer.requestFullscreen().catch(err => {
                console.error('Error attempting to enable fullscreen:', err);
            });        } else {
            document.exitFullscreen();
        }
    }
    
    // Enhanced page navigation with haptic feedback and accessibility
    addPageNavigationFeedback() {
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => {
                this.triggerNavigationFeedback('prev');
            });
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => {
                this.triggerNavigationFeedback('next');
            });
        }
    }
    
    triggerNavigationFeedback(direction) {
        // Haptic feedback for mobile devices
        if ('vibrate' in navigator) {
            navigator.vibrate(50); // Short vibration
        }
        
        // Visual feedback ripple effect
        const button = document.getElementById(`${direction}-page-btn`);
        if (button) {
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
                button.style.transform = '';
            }, 100);
        }
        
        // Announce page change for screen readers
        this.announcePageChange();
    }
    
    announcePageChange() {
        // Create or update screen reader announcement
        let announcement = document.getElementById('page-announcement');
        if (!announcement) {
            announcement = document.createElement('div');
            announcement.id = 'page-announcement';
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.style.position = 'absolute';
            announcement.style.left = '-10000px';
            announcement.style.width = '1px';
            announcement.style.height = '1px';
            announcement.style.overflow = 'hidden';
            document.body.appendChild(announcement);
        }
        
        const pageText = `Page ${this.currentPageIndex + 1} of ${this.totalPages}`;
        announcement.textContent = pageText;
    }

    // Helper methods for document preview
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    tryOfficeOnlinePreview(fileName) {
        // This would typically open a modal or new tab with online preview
        // For now, show an informational message
        this.showToast(`Online preview for ${fileName} would require Microsoft Office Online integration`, 'info');
    }
    
    showDocumentInfo(fileName) {
        const file = this.selectedFiles.find(f => f.name === fileName);
        if (!file) return;
        
        const createdDate = file.lastModified ? new Date(file.lastModified).toLocaleString() : 'Unknown';
        
        const infoHtml = `
            <div class="document-info-modal">
                <h4>File Properties</h4>
                <div class="info-row"><strong>Name:</strong> ${file.name}</div>
                <div class="info-row"><strong>Size:</strong> ${this.formatFileSize(file.size)}</div>
                <div class="info-row"><strong>Type:</strong> ${file.type || 'Unknown'}</div>
                <div class="info-row"><strong>Last Modified:</strong> ${createdDate}</div>
            </div>
        `;
        
        this.showToast(infoHtml, 'info', 5000);
    }
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.app = new SendAnywhereApp();
    
    // Add debug keyboard shortcut (Ctrl+D)
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'd') {
            e.preventDefault();
            window.app.debugFileSelection();
        }
    });
    
    // Expose debug function globally for console access
    window.debugFileSelection = () => window.app.debugFileSelection();
});
